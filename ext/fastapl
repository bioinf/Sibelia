#!/usr/bin/perl -w
#  Author: Paul Horton
#  Organization: Computational Biology Research Center, AIST, Japan
#  Copyright (C) 2010 Paul Horton, All rights reserved.
#  Creation Date: 2010.8.19
#  Last Modification: $Date: 2012/04/21 08:53:54 $
#
#  License: GNU General Public License (GPLv3)
#
#  Description: Fasta format stream processing utility.
#               Fasta Perl Loop  or fastapl (pronounced "fast apple")
#               See pod at bottom of file for more details.
#
#  Credits:
#    minor code improvements: Martin Frith, Raymond Wan
#    early testers: The above + Junko Tsuji
#    -M module loading argument suggested by Edward Wijaya.
#

# ===================  NOTES TO HELP UNDERSTAND THIS CODE  ==================

# *------------------  Varible Naming and Use Conventions  ------------------*
#
#  Variables visible in the scope of the eval statements of user provided
#  code {begin, record, end} scripts, should end in '_', e.g. $line_
#  UNLESS they are intended to be available to users, e.g. $seq, @seq, etc.
#
#  The only subroutines purposely exposed to the user are
#  'asHash()' and 'pr()'.
#  Other subroutines should start in '_', e.g. _extractBlock().
#
#  A "flag" means an argument with a binary value, e.g. the '-p' flag
#  Variables read from the command line SHOULD NOT BE MODIFIED THEREAFTER.
#  Command line flags for documentation are placed in %docFlag
#  Variables holding the value other command line arguments should be
#  named ending in '_arg_' or, if they are flags, '_flag_'.
#
#
# *------------------      Unusual Code Constructs       -------------------*
# 
# HERE DOCUMENTS:
#   This program is unusual in that it prints part of itself when
#   the -n|--generate-standalone option is given.
#
#   The following here document construct is used to print part of this
#   file out. The leading |'s are just used to visually separate this
#   data from the real code. They are removed by the 's/^.//mg'
#
#     $_  =  <<"_____END_STANDALONE_PART_____";   s/^.//mg;   print;
#     |#!/usr/bin/perl -w
#     |#  This script was generated by fastapl version $::VERSION
#     ...
#     _____END_STANDALONE_PART_____
#
#
# SPECIAL COMMENTS FOR GENERATING STANDALONE PROGAM:
#   This code has some special comments like
#
#     #== BEG_SKIP
#     ...
#     #== END_SKIP
#
#     @seq = undef;  #== IF	$needSeqArray_
#     ...
#
#   Also introduced for the -n|--generate-standalone option, these special
#   comments are used to conditionally include parts of this file in the
#   generated standalone program.  See sub _printCommonCode() for details.
#

# ===================  NOTES TO HELP UNDERSTAND THIS CODE  ==================


use List::Util qw(first max maxstr min minstr reduce shuffle sum);


$VERSION = '1.10';
use strict;
use Getopt::Long qw(:config posix_default bundling permute);
use Pod::Usage;
use Text::Balanced qw( extract_codeblock );  # to extract BEGIN, END blocks
use IO::File;                                # for ungetc()

use feature qw(say);


# -------------------------  Global Variables  -------------------------
#  Some global variables not intended to be accessed by user scripts.

my @rec_;  #  stores all records, only used with --sort.

my $podSource_;    # pathname to pod source file, undef means use $0.

my $fieldSeparator_arg_  =  "";  # field separator used to compute @head.
my $modules_arg_      =  undef;  # modules passed by user for use in script. Array ref.

#  Scripts passed directly from command line.
my $mainScript_arg_  =  "";  # record script + (optionally) BEGIN and/or END blocks.
my $begScript_arg_   =  "";  # begin script, alternative way to give BEGIN block.
my $endScript_arg_   =  "";  #   end script, alternative way to give  END  block.

#  Mutually exclusive ways for user to stipulate output sequence line length.
my $printSeqOn1Line_flag_ =  0;  #   If true, output sequences on one line.
my $seqLineLength_arg_    =  undef;  #  undef means to heuristicially guess length from input.

my $validSeqChars_arg_  =  '-a-zA-Z';   # chars allowed in sequence, others are skipped.

my $generateStandalone_flag_= 0;  # if true, output program with scripts embedded.
my $grepMode_flag_          = 0;  # if true, print record iff user record script returns true.
my $printEachRecord_flag_   = 0;  # if true, print each record after processing.
my $printVersion_flag_      = 0;  # if true, just print version and exit.
my $sortMode_flag_          = 0;  # if true, sort records by user given script.

#  These will actually be eval'd
my $begScript_  = "";  # progam code to apply before processing records.
my $recScript_  = "";  # progam code to apply to each record.
my $endScript_  = "";  # progam code to apply after processing records.

my $outputFile_arg_ = "";  #  Output filename. If omitted output goes to STDOUT.

my %scriptUses_;    #  What record vars needed.  Used to reduce memory use when possible.
my $needSeqArray_;  #  true iff @seq is needed.


{   # ----------  BEG: Process command line  ----------
    my %docFlag = ();
    my @commandLineOptionSpecs = (
        'help',                   =>  \$docFlag{help},
        'man',                    =>  \$docFlag{man},
        'usage'                   =>  \$docFlag{usage},
        'options'                 =>  \$docFlag{options},
        'g|grep'                  =>  \$grepMode_flag_,
        'n|generate-standalone'   =>  \$generateStandalone_flag_,
        'p|print-each-record'     =>  \$printEachRecord_flag_,
        '1|print-seq-on-1-line'   =>  \$printSeqOn1Line_flag_,
        's|sort'                  =>  \$sortMode_flag_,
#        v|verbose   Reserved for possible future addition.
        'V|version'               =>  \$printVersion_flag_,
        'F|field-separator=s'     =>  \$fieldSeparator_arg_,
        'M|module=s@'             =>  \$modules_arg_,
        'e|script=s'              =>  \$mainScript_arg_,
        'b|begin=s'               =>  \$begScript_arg_,
        'f|end=s'                 =>  \$endScript_arg_,
        'l|line-length=i'         =>  \$seqLineLength_arg_,
        'o|output-file=s'         =>  \$outputFile_arg_,
        'c|valid-seq-chars=s'     =>  \$validSeqChars_arg_,
        );


    # ---------  Use Japanese usage messages, if LANG calls for that  ---------
    if(  $ENV{LANG} =~ /^ja_JP/i  and  $ENV{LANG} =~ /utf[_-]*8$/i  ){

        my $nihongoPodFilename  =  'fastapl.ja.utf8.pod';  # constant.

        my $pathToNihongoPod  =  `which $nihongoPodFilename`;
        if(  $pathToNihongoPod  ){
            $podSource_ = "$pathToNihongoPod/$nihongoPodFilename";
        }
        else{
            if( -e "./$nihongoPodFilename" ){
                $podSource_ = "./$nihongoPodFilename";
            }
        }
    }


    my $getOptionsRetval  =  GetOptions( @commandLineOptionSpecs );

    $getOptionsRetval  or  _pod2usage();


    # ----------  Process flags related to usage documentation  ----------
    {
        my $isDumbTerminal   =   exists($ENV{TERM})  &&  $ENV{TERM} eq 'dumb';

        $docFlag{man}    and  _pod2usage( -verbose => 2,
                                          -noperldoc => $isDumbTerminal );
        $docFlag{help}   and  _pod2usage( -verbose => 1 );
        $docFlag{usage}  and  _pod2usage( -verbose => 0 );

        my @optionSummary  =  (
            'g|grep                 Output record iff user script returns true',
            'n|generate-standalone  Generate standalone program instead of processing input',
            'p|print-each-record    Print each record after executing user script on it',
            '1|print-seq-on-1-line  Print sequence part of record all on one line',
            's|sort                 Sort records according to user script',
#            v|verbose   Reserved for possible future addition.
            'V|version              Print version of fastapl',
            'F|field-separator x    Use x as field separator when computing @head',
            'M|module x             Load module x before executing user scripts',
            'e|script x             Execute script x on each record',
            'b|begin x              Execute script x before reading input',
            'f|end x                Execute script x after processing input',
            'l|line-length x        Print sequence with line length x',
            'o|output-file x        Print output of file x',
            'c|valid-seq-chars x    Characters not matching x ignored in sequence',
            );

        if(  $docFlag{options}  ){
            say " $_"  for(@optionSummary);
            exit 1;
        }

    }   # ----------  END: Process flags related to usage documentation  ----------

}   # ----------  END: Process command line  ----------


# ----------  Open output files  ----------
my $os_  =  *STDOUT;   #  Output stream.
if(  $outputFile_arg_  ){
    open $os_, '>', $outputFile_arg_
        or   _printUsageError(  "could not open output file '$outputFile_arg_'\n"  );
}


if(  $printVersion_flag_  ){
    print $os_ "fastapl $::VERSION   Fasta Perl Loop   Copyright (C) 2010,2011 Paul Horton\n";
    exit 1;
}


# ----------  Check for contradictory options  ----------
if(  $printEachRecord_flag_  &&  $grepMode_flag_  ){
    _printUsageError(  'only one of {-g|--grep, -p|--print-each-record} allowed.'  );
}

if(  $sortMode_flag_  &&  $endScript_arg_  ){
    _printUsageError(  'only one of {-s|--sort, -f|--end} allowed.'  );
}

if(  $sortMode_flag_  &&  $printEachRecord_flag_  ){
    _printUsageError(  'only one of {-s|--sort, -p|--print-each-record} allowed.'  );
}

if(  $printSeqOn1Line_flag_  &&  $seqLineLength_arg_  ){
    _printUsageError(
        "'l|line-length' and '1|print-seq-on-1-line' cannot both be chosen."
        );
}


# ----------  Check for invalid command line option values  ----------
if(  defined( $seqLineLength_arg_ )  ){
    $seqLineLength_arg_ > 0   or
        _printUsageError(
            "expected positive integer for 'l|line-length', but got $seqLineLength_arg_."
        );
}


# ----------  Check number of command line args given  ----------
{
    my $numScriptFileArgsExpected  =  ( $mainScript_arg_ ?  0 : 1 );

    if(  @ARGV < $numScriptFileArgsExpected  ){
        #  Empty script is allowed with combination of -p with -l or -1 on the command line.
        $printEachRecord_flag_ && ($seqLineLength_arg_ || $printSeqOn1Line_flag_)
            or  _printUsageError(  'expected more arguments.'  )
    }
}



# ----------  preload modules  ----------
for my $module (@$modules_arg_){
    eval(  "use $module;"  );
    $@  and  die( "Error when loading module: '$module'; $!\n" );
}


# ----------  Read scripts in from command line or file  ----------

if(  $mainScript_arg_  ){

    #  If mainScript_arg_ is an existing file, someone's probably confused.
    #  Newline clause is to avoid warning message when stat'ing with -e
    if(  $mainScript_arg_ !~ /\n/  and  -e $mainScript_arg_  ){
        _printUsageError(  "'-e' is used to input inline scripts directly from the command line, but a file named '$mainScript_arg_' exists, so I guess you probably did not need the '-e'."  );
    }

    my $entireScript  =  $mainScript_arg_;

    $begScript_  =  _extractBlock( \$entireScript, 'BEGIN' );

    if(  $begScript_arg_  ){
        if(  $begScript_  ){ 
            _printUsageError(  "--begin used but BEGIN block also found in the inline script"  );
        }
        else{
            $begScript_  =  $begScript_arg_;
        }
    }

    $endScript_    =  _extractBlock( \$entireScript, 'END' );

    if(  $endScript_arg_  ){
        if(  $endScript_  ){
            _printUsageError(  "-f|--end given but END block also found in the inline script"  );
        }
        else{
            $endScript_  =  $endScript_arg_;
        }
    }

    $recScript_  =  $entireScript;

}
else{  # -----  Script not given directly on the command line  -----
    
    if(  $begScript_arg_  ){
        _printUsageError(  "'-b|--begin' flag given without '-e'"  );
    }

    if(  $endScript_arg_  ){
        _printUsageError(  "'-f|--end' flag given without '-e'"  );
    }

    my $scriptFilename  =  shift @ARGV;

    my $scriptFile;
    if(  $scriptFilename  ){
        unless(  -e $scriptFilename  ){
            my $m  =  "script file '$scriptFilename' does not exist.";
            _looksLikePerlCode( $scriptFilename )
                and   $m  .=  "\nPerhaps you forgot the '-e'?";

            _printUsageError(  $m  );
        }

        if(  _looksLikeFastaFile( $scriptFilename )  ){
            if(  $printEachRecord_flag_ && ($seqLineLength_arg_ || $printSeqOn1Line_flag_)  ){
                #  Empty script is allowed with combination of -p with -l or -1 on command line.
                unshift @ARGV, $scriptFilename;  # filename argument is input file not script file.
                goto SCRIPT_ASSIGNED;
            }
            _printUsageError( 
                "filename '$scriptFilename' was given as a script file, but it looks like a fasta input file\nPerhaps you forgot to give the script or script file?"
                );
        }
        
        open( $scriptFile, '<', $scriptFilename )
            or  die( "could not open script file: '$scriptFilename',$!\n" );

        my $entireScript  =  do { local $/; <$scriptFile> };  # Slurp whole file.

        $begScript_   =  _extractBlock( \$entireScript, 'BEGIN' );

        $endScript_   =    _extractBlock( \$entireScript, 'END' );

        $recScript_  =  $entireScript;
    } #  END if: $scriptFilename

} #  END else: read script from file.
 SCRIPT_ASSIGNED:


#  -----  Make sure there are no END blocks in sort mode  -----
if(  $endScript_  and  $sortMode_flag_  ){
    _printUsageError(  'sort mode does not accept END blocks.'  );
}


# --------  Remove any leading and white space in scripts  --------
$begScript_  =~  s{ ^\s* | \s*$ } {}gx;
$endScript_  =~  s{ ^\s* | \s*$ } {}gx;
$recScript_  =~  s{ ^\s* | \s*$ } {}gx;

die( "Error: empty script\n" )   if(  $recScript_ =~ /^{}$/  );

# -----  Ensure non-empty scripts end in ';'  -----
$recScript_  =~  s{  ([^;])$} {$1;}x;
$begScript_  and  $begScript_ =~ s{  ([^;])$} {$1;}x;
$endScript_  and  $endScript_ =~ s{  ([^;])$} {$1;}x;



#  -----  Check if scripts appear well formed  -----
_dieIfBadScript( $recScript_, 'record' );

$begScript_  and
    _dieIfBadScript( $begScript_, 'BEGIN' );

$endScript_  and
    _dieIfBadScript( $endScript_, 'END' );


#  -----  Analyze script to determine which record vars are needed  -----
_setScriptUses();
$needSeqArray_  =  $scriptUses_{'@seq'};


# ----------  Check and set field separator  ----------
if( $fieldSeparator_arg_  =~  /\n/ ){
    _printUsageError( 'field separator should not be multi-line.' );
}


#  Field separator used when computing @head.
my $fs  =   $fieldSeparator_arg_ ?  $fieldSeparator_arg_  :  '\t';


if(  $generateStandalone_flag_  ){
    @ARGV   and   _printUsageError(  "No arguments expected with -n flag. Extra argument: '$ARGV[0]'"  );

    _printStandalone_thenExit();  #  <---------   EARLY EXIT POINT!   <--------
}


my @fastaInputFilename_;  _setFastaInputFilenames();


# ----------  Declare variables intended for user  ----------

my $head =    "";  #  head line (line starting with '>').
my @head;          #  head line after id, split by $fs into array.
my $id =      "";  #  record id (non-white-space string following the '>').
my $comment = "";  #  record comment lines as single string (newlines included).
my $seq =     "";  #  sequence as scalar.
my @seq;           #  sequence as array, one element per residue.


# ----------   Private global variables  ----------

my $noHeadSeenYet_  =  'true';  #  no record has yet been seen?


my $commentAtStartOfStream = "";  #  Will hold comment lines at begining of stream;
                                  #  emptied after printed once by pr().

my $maxSeqLineLenSeen_ = 0;  #  Length of longest input sequence length seen so far.
my $numSeqLines_;            #  Number of sequence lines.


# ----------  Execute begin script  ----------
{    no strict   'vars';
     no warnings 'redefine';
     eval $begScript_;
     $@  and  die( "Error in BEGIN script; $!\n" );
}


# ----------  Execute record script on each record  ----------
for my $fastaInputFilename (@fastaInputFilename_){

    my $fastaInputStream;

    if(  $fastaInputFilename eq '-'  ){
        $fastaInputStream  =  *STDIN;
    }else{
        open( $fastaInputStream, '<', $fastaInputFilename )
            or  die(  "could not open fasta file '$fastaInputFilename', $!\n"  );
    }

    _processInputStream( $fastaInputStream );

}  # END:  for $fastaInputFilename (@fastaInputFilename_)



if( $sortMode_flag_ ){

    local $SIG{__WARN__}
    = sub{
        print STDERR "Error: $!\n";
        (  my $head1, my $headAref1, my $id1, my $seq1  )  =  @$a;
        (  my $head2, my $headAref2, my $id2, my $seq2  )  =  @$b;
        print STDERR "last compared ids: ( $id1, $id2 )\n";
        exit 1;
    };

    @rec_  =  sort _compareRecords @rec_;
    _printSortedRecords();
}
else{
    # ----------  Execute end script  ----------
    {    no strict 'vars';
         eval $endScript_;
         $@  and  die( "Error in END script; $!\n" );
    }
}

exit 0; #  Return success to shell.


# ============================  END MAIN PROGRAM  =============================


#  Return hash holding any KEY=VALUE pairs present in @_
#  @_ defaults to @head.
sub asHash{
    
    @_   or   @_  =  @head;

    my @keyValuePairs;

    #                             KEY     =    VALUE
    push  @keyValuePairs,  /^  ( [^=]+ )  =  ( [^=]+ )  $/x    for( @_ );

    return @keyValuePairs;
}


#  Print $message to STDERR.
#  if $os_ is a terminal:  print usage summary to it;  otherwise print $message to it.
sub _printUsageError{
    my $message  =  'Command line parsing error; '  .  $_[0]  .  "\n";
    print STDERR $message;
    if(  -t  $os_  ){
        print $os_ <<___USAGE_MESSAGE_END___
Usage:
  fastapl [opts] SCRIPT [fasta_input_file...]
  fastapl [opts] -n SCRIPT  >  prog.pl

      SCRIPT  =>  script_file  |
                  [-b beginScript]  -e script  [-f endScript]

  fastapl [--usage|--options|--help|--man]
___USAGE_MESSAGE_END___
    }
    else{
        print $os_ "fastapl: $message";
    }

    exit -1;

} #  END: _printUsageError( $message )



#  Wrapper for pod2usage. Used to support conditional use of non-English documentation.
sub _pod2usage{
    $podSource_ ?  pod2usage( @_, -input => $podSource_ )  :  pod2usage( @_ );
}


#  Use eval to test if $script appears to be well-formed Perl.
#  Die with warning if it fails.
#  $label (e.g. 'BEGIN'), is only used for diagnostic messages.
sub _dieIfBadScript{
    my ( $script, $label )  =  @_;

    my $numScriptLines   =   1  +  $script =~ tr/\n//;

    #  Arrange for any warnings generated by evaling $script
    #  to be added to eval error messages.  Both stored in $@.
    local $SIG{__WARN__}  =  sub { $@ .= $_[0] };

    eval  "no strict qw(vars); use warnings; sub{ $script; }";

    $@   or   return;  #  <---------   RETURN HERE MEANS SCRIPT OKAY


    #  Otherwise, eval detected an error or warning...

    my @diagnosticLine  =  $@;

    #  Print script and diagnostic message in reasonable format.
    if(  $numScriptLines == 1  ){
        print $os_ "\nError in $label script:\n";
        print $os_ "    '$script'\n\n";
        if(  @diagnosticLine == 1  ){
            print $os_ "diagnostic:  $diagnosticLine[0]";
        }
        else{
            print $os_ "diagnostic:";
            print $os_ "    $_"  for( @diagnosticLine );
        }
    }
    else{
        print $os_ "\nError in $label script:\n\n";
        print $os_ "$script";
        print $os_ "\ndiagnostic:\n";
        print $os_ "    $_"  for( @diagnosticLine );
    }
    exit -1;

} #  END: _dieIfBadScript( $script, $label )



#  Extract first occurrence of code block labeled $blockLabel in $$scriptRef
#  if successful 1) remove block from $$scriptRef.
#                2) return the block.
#  else   leave $$scriptRef unchanged and return "".
sub _extractBlock{
    ( my $scriptRef, my $blockLabel )  =  @_;

    my $blockScript;  # to hold block contents and return.

    if(  ( my $upToBlockLabel, my $rest ) = 
         (  $$scriptRef  =~  / ^(.*?) $blockLabel \s* ({ .* ) /xs   )
        ){
        
        if(   $blockScript  =  extract_codeblock( $rest, '{}' )   ){
            $$scriptRef  =  $upToBlockLabel . $rest;
        }

        if(   $$scriptRef  =~  / $blockLabel \s* { /x  ){
            die "script only allowed one $blockLabel block";
        }

        return( $blockScript );
    }

    return( "" );

} #  END: _extractBlock( $scriptRef, $blockLabel )



sub _printStandalone_thenExit{
    open( my $myselfAsFile, $0 )
        or  die "Progam Error: Could not open file containing self, $!";

    _printStandalonePart1();

    say $os_ 'my $maxSeqLineLenSeen_ = 0;  #  Length of longest input sequence length seen so far.'
        if( !$printSeqOn1Line_flag_ );

    print $os_ '$fs = ', "'$fs';\n\n"   if(  $fieldSeparator_arg_  );

    if(  $begScript_  ){
        print $os_ "# --------------------  BEG: User Begin Script  --------------------\n";
        print $os_ $begScript_;
        print $os_ "# --------------------  END: User Begin Script  --------------------\n";
    }

    _printStandalonePart2();

    if(  $sortMode_flag_  ){
        print $os_ '@rec_  =  sort _compareRecords @rec_;', "\n";
        print $os_ "\n_printSortedRecords();\n";
    }

    if(  $endScript_  ){
        print $os_
            "# --------------------  BEG: User end Script  --------------------\n",
            "{   no warnings 'once';\n",
            "    $endScript_\n",
            "}\n",
            "# --------------------  END: User end Script  --------------------\n\n\n";
    }

    print $os_ "\n\n# ====================  End Main Program  ====================\n\n\n";

    _printCommonCode();
    _printStandaloneSubs();

    exit 0; # return success.

} # END: _printStandalone_thenExit()



#  Print part1 of standard program, up to where the BEGIN script goes.
#  Only used with -n|--generate-standalone option.
sub _printStandalonePart1{

    say $os_  '#!/usr/bin/perl -w'                                          ;
    say $os_  '#  This script was generated by fastapl version ', $::VERSION;
    say $os_  ''                                                            ;
    say $os_  'use IO::File;  # for ungetc()'                               ;


    for my $module (@$modules_arg_){
        say $os_  ''                                                               ;
        say $os_  'eval(  "use ',$module,';"  );'                                  ;
        say $os_  '$@  and  die( "Error when loading module: ',$module,'; $!\n" );';
    }

    say $os_  ''                                               ;
    say $os_  'my $usage  =  "Usage: $0 [fastaInputFile...]\n"';
    say $os_  '                  .  "$0  <  fastaInputFile";'  ;

    say $os_  ''                                                                     ;
    say $os_  '#  Parameters normally read or configurable from fastapl command line';
    say $os_  '#  In this generated standalone program they are constants.'          ;

    print $os_
"my \$validSeqChars_arg_     =  '$validSeqChars_arg_';  #  Chars allowed in sequence, others are skipped.\n",
"my \$printSeqOn1Line_flag_  =  ",
( $printSeqOn1Line_flag_? "'true'" : 'undef' ), ";  #  If true, output sequences on one line.\n",
"my \$seqLineLength_arg_     =  ",
( $seqLineLength_arg_?  $seqLineLength_arg_ : 'undef' ), ";  #  Otherwise, use this length if defined.\n";


say $os_  '';                                                                               ;
say $os_  '# ----------  Open input and output files  ----------'                           ;
say $os_  'my $os_  =  *STDOUT;   #  Output stream.'                                        ;
say $os_  '_standalone_parseArgvOptions();'                                                 ;
say $os_  ''                                                                                ;
say $os_  'my @fastaInputFilename_;  _setFastaInputFilenames();'                            ;
say $os_  ''                                                                                ;
say $os_  '# ----------  Declare variables intended for user  ----------'                   ;
say $os_  ''                                                                                ;
say $os_  'my $fs   = "\t"; # field separator used when computing @head.'                   ;
say $os_  'my $head =  ""; #  head line (line starting with ">").'                          ;
say $os_  'my @head;          # head line after id, split by $fs into array.'               ;
say $os_  'my $id   = "";     # record id (non-white-space string following the ">").'      ;
say $os_  'my $comment = "";  # record comment lines as single string (newlines included).' ;
say $os_  'my $seq  = "";     # sequence as scalar.'                                        ;

$needSeqArray_ and
say $os_  'my @seq;          # sequence as array, one element per residue.'                    ;
say $os_  ''                                                                                   ;
say $os_  ''                                                                                   ;
say $os_  'my $commentAtStartOfStream = "";  #  Will hold comment lines at begining of stream;';
say $os_  '                                  #  emptied after printed once by pr().'           ;
say $os_  ''                                                                                   ;
say $os_  '# ----------   Private global variables  ----------'                                ;
say $os_  'my $noHeadSeenYet_  =  \'true\';  #  no record has yet been seen?'                  ;
} #  END: _printStandalonePart1()


#  Print part2 of standalone program, from begin script to where record script goes
#  Only used with the -n|--generate-standalone option.
sub _printStandalonePart2{

    #  Print following code lines, sans the leading '|'.
    $_  =  <<'_____END_STANDALONE_PART_____';   s/^.//mg;   print $os_ $_;
|
|for my $fastaInputFilename (@fastaInputFilename_){
|
|    my $fastaInputStream;
|
|    if(  $fastaInputFilename eq '-'  ){
|        $fastaInputStream  =  *STDIN;
|    }else{
|        open( $fastaInputStream, '<', $fastaInputFilename )
|            or  die(  "could not open fasta file '$fastaInputFilename', $!\n"  );
|    }
|
|    _processInputStream( $fastaInputStream );
|
|}  # END:  for $fastaInputFilename (@fastaInputFilename_)
|
|
_____END_STANDALONE_PART_____
} #  END: _printStandalonePart2()



#  Print part of this file itself (slightly modified according to user options)
#  as subroutines to use in standalone program,
#  generated when the -n|--generate-standalone option is stipulated.
sub _printCommonCode{

    #  ----------  Gather part of this file usually included  ----------

    my $begRegex  =  qr/^#== BEG_INCLUDE-COMMON/;
    my $endRegex  =  qr/^#== END_INCLUDE-COMMON/;

    my @regionToInclude  =  _myLinesBetweenMarkers( $begRegex, $endRegex );


    #  ----------  Include part of this file only used when sorting  ----------
    if(  $sortMode_flag_  ){
        $begRegex  =  qr/^#== BEG_INCLUDE-IF-SORTING/;
        $endRegex  =  qr/^#== END_INCLUDE-IF-SORTING/;

        push  @regionToInclude,  _myLinesBetweenMarkers( $begRegex, $endRegex );
    }


  LINE:
    while(   my $line  =  shift @regionToInclude   ){

        chop $line;

        #  Skip single line.
        next LINE
            if(   $line  =~  /#== SKIP/   );

        #  Skip block
        if(  $line =~ /#== BEG_SKIP/  ){
            $line  =  shift @regionToInclude
                while(  $line !~ /#== END_SKIP/  );
            next LINE;
        }

        #  ---------  Conditional Inclusion, one-line if statements  ---------

        #  Comment in main program; but conditionally included in standalone program.
        #
        #                INDENTATION    #       IF         CONDITION       TEXT
        if( $line =~  m{  ^ (\s+)      \#== \s+ IF \s* \t  ([^\t]+) \t \s* (.*) $  }x   ){
            say $os_ $1,$3   if(  eval $2  );
            next LINE;
        }

        #  Real code in main program. Also conditionally included in standalone program.
        #                       TEXT    #       IF   CONDITION 
        if(   $line  =~  m{  ^ ([^#]+) \#== \s+ IF \s+ (.*) $  }x   ){
            say $os_ $1   if(  eval $2  );
            next LINE;
        }


        #  Directive to embed apropriate code.
        if(  $line =~ /#== EMBED-RECORD-SCRIPT/  ){

            next LINE
                if(  $sortMode_flag_  &&  ($line =~ /UNLESS-SORTING/)  );

            print $os_ _embeddedRecordScript(  $sortMode_flag_? 4 : 16  );

            $grepMode_flag_  and
                say $os_  '                pr()  if( $retVal );';

            $printEachRecord_flag_  and
                say $os_  '                pr();';

            next LINE;
        } #  END:= EMBED-RECORD-SCRIPT


        #  Directive to embed apropriate code.
        if(  $line =~ /#== STORE-RECORD-IF-SORT-MODE/  ){
            if(  $sortMode_flag_  ){
                #  In sort mode, embed code to push record information onto @rec
                my $spc  =  ' '  x  12;
                print $os_
                    "$spc",  'push @rec_,'                              , "\n",
                    "$spc",  '  [   $head,  [map {$_} @head],'          , "\n",
                    "$spc",  '      $id,  $comment,'                    , "\n",
                    "$spc",  '      $seq,'                              , "\n",
                    "$spc",  '  ];'                                     , "\n";
            }
            next LINE;
        } #  END:= STORE-RECORD-IF-SORT-MODE

        $line !~ /#==/  or  die( "unparsed directive: '$line'" );

        #  Default case, just print $line and continue looping.
        say $os_ $line;

    } #  END: for $line in @regionToInclude

} #  END: _printCommonCode()


#  Return $recScript_ in suitable form to embed in source code
#  indented with $numSpaces spaces.
sub _embeddedRecordScript{
    my $numSpaces  =  shift;
    my $spc   =   ' '  x  $numSpaces;  # leading space to indent code.
    my $ms   =   $recScript_;
    $ms  =~  s/(^|\n)/$spc    $1/mg;    # indented code
    return "\n${spc}my \$retVal  =  do{  #  User given record script\n$ms\n$spc};\n\n";
}


#  Return lines in this file between $begRegex and $endRegex match pairs
#  non-inclusive and also skipping the line right after the $begRegex match.
sub _myLinesBetweenMarkers{
    ( my $begRegex, my $endRegex )  =  @_;

    my $myselfAsFile  =  IO::File->new(  "< $0"  );

    my @retVal;
    ( my $prevLine1, my $prevLine2 )  =  ( "", "" );
    my $skip  =  1;  # true.

    while(  <$myselfAsFile>  ){
        my $curLine   =  $_;
        $skip = 0   if(  $prevLine2 =~ /$begRegex/  );
        $skip = 1   if(  $curLine   =~ /$endRegex/  );
        $skip  or  push @retVal, $curLine;
        $prevLine2  =  $prevLine1;
        $prevLine1  =  $curLine;
    }

    close $myselfAsFile;

    return @retVal;
} #  END: _myLinesBetweenMarkers( $begRegex, $endRegex )



#  Print subroutines used only by automatically generated programs.
#  Only used with -n|--generate-standalone option.
sub _printStandaloneSubs{

    #  Print following code lines, sans the leading '|'.
    $_ = <<'_____END_STANDALONE_SUBS_____';   s/^.//mg;   print $os_ $_;
|
|#  Print $message to STDERR. If $os_ is a terminal print to $os_ as well.
|sub _printUsageError{
|    my $message  =  'Command line parsing error; '  .  $_[0]  .  "\n";
|    print STDERR $message;
|    print $os_ "$0: $message"   unless( -t $os_ );
|    exit -1;
|}
|
_____END_STANDALONE_SUBS_____
} #  END: _printStandaloneSubs()



#  Analyze $recScript_ to see what record variables are used.
#  to consider: strip comments from script first.
sub _setScriptUses{

    $scriptUses_{ '$seq' }
    =      $recScript_  =~  m{  \$ \s* seq \s* \W  }x;

    $scriptUses_{ '@seq' }
    =      $recScript_  =~  m{   @ \s* seq         }x   ?   1
        :  $recScript_  =~  m{  \$ \s* seq \s* \[  }x   ?   1
        :  $recScript_  =~  m{  \$ \#  seq \s* \W  }x   ?   1
        :                                                   0;

}



#== BEG_INCLUDE-IF-SORTING
# =============================================================================

#  Print records in @rec_.  Used after sorting.
sub _printSortedRecords{

    print $os_ $commentAtStartOfStream;
    for my $recRef (@rec_){

        print $os_ ">$recRef->[0]\n";   #  $head

        print $os_ $recRef->[3];  #  comment

        $seq  =  $recRef->[4];

        if( $printSeqOn1Line_flag_ ){   say $os_ $seq;   }  #== SKIP
        else                        {   _printSeq();     }  #== SKIP

        #== IF	 $printSeqOn1Line_flag_	 say $os_ $seq;
        #== IF	!$printSeqOn1Line_flag_	 _printSeq();

    }
} #  END: _printSortedRecords()


#  Compare records according to $recScript_.  Used to sort records.
sub _compareRecords{
    no warnings 'once';
    no strict 'vars';

    (  my $head1, my $headAref1, my $id1, my $comment1, my $seq1  )   =   @$a;
    (  my $head2, my $headAref2, my $id2, my $comment2, my $seq2  )   =   @$b;

    *head1 = \@$headAref1;
    *head2 = \@$headAref2;

    if( $needSeqArray_ ){            #== SKIP
        @seq1  =  split //, $seq1;   #== IF  $needSeqArray_
        @seq2  =  split //, $seq2;   #== IF  $needSeqArray_
    }                                #== SKIP

    #== EMBED-RECORD-SCRIPT
    my $retVal  =  eval $recScript_;                 #== SKIP
    $@  and  die( "Error in record script; $!\n" );  #== SKIP

    return $retVal;

} #  END: _compareRecords()


#== END_INCLUDE-IF-SORTING
# =============================================================================


#== BEG_INCLUDE-COMMON
# =============================================================================


#  Print input parsing error and exit.
sub _printInputError{
    my $message  =  shift;
    _printError(  'Input parsing error; '  .  $message  .  "\n"  );
    exit -1;
}


#  Print $message to STDERR and, if not connected to terminal, to $os_ as well.
sub _printError{
    my $message  =  shift;
    print STDERR $message;
    print $os_ "fastapl: $message"   unless(  -t $os_  );
}


#  Open and process each file found in global: @fastaInputFilename_.
sub _loopOverFastaInputFilenames{

    for my $fastaInputFilename (@fastaInputFilename_){

        my $fastaInputStream;

        if(  $fastaInputFilename eq '-'  ){
            $fastaInputStream  =  *STDIN;
        }else{
            open( $fastaInputStream, '<', $fastaInputFilename )
                or  die(  "could not open fasta file '$fastaInputFilename', $!\n"  );
        }

        _processInputStream( $fastaInputStream );

    }  # END:  for $fastaInputFilename (@fastaInputFilename_)

} # END: _loopOverFastaInputFilenames



#  Set @fastaInputFilename_ from @ARGV.
sub _setFastaInputFilenames{
    my $numStdinArgs  =  0;
    for my $filename (@ARGV){
        push  @fastaInputFilename_, $filename;
        if(  $filename eq '-'  ){
            if(  $numStdinArgs++  ){
                _printUsageError(  'STDIN given as input twice'  );
            }
            if(  -t *STDIN  ){
                _printUsageError(  'STDIN stipulated for input, but is attached to a terminal'  );
            }
        }
        else{  # filename ne '-'
            _looksLikeFastaFile( $filename )
                or  _printUsageError(  "file '$filename' is not a fasta file"  );
        }
    }

    if(  !@fastaInputFilename_  ){
        if(  -t *STDIN  ){
            my $m = "STDIN stipulated for input, but is attached to a terminal.\n"
                .   'Perhaps you forgot to give a fasta input file?';
            _printUsageError( $m );
        }
        push  @fastaInputFilename_, '-';  # no input arg given, so use STDIN.
    }
} #  END: _setFastaInputFilenames( filenames... )



#  Read records and run record script on contents of $fastaInputStream_
sub _processInputStream{
    my $fastaInputStream_  =  shift;

    my $line_;                #  Current input line.


    #== BEG_SKIP
    #  Override warn() and die() to tell user error happened during record script execution.
    local $SIG{__WARN__}
    = sub{
        my $message  =  shift;
        $message =~ s/ at \(eval \d+\) line \d+.*$/./;
        my $numScriptLines   =   1  +  $recScript_ =~ tr/\n//;
        _printError( "\nWarning when executing record script on id '$id'" );
        _printError(  ( $numScriptLines  <  20  )
                      ?  ":\n\n  $recScript_\n\n$message"
                      :  ". $message"                      );
        undef $SIG{__WARN__};
        exit -1;
    };

    local $SIG{__DIE__}
    = sub{
        my $message  =  shift;
        $message =~ s/ at \(eval \d+\) line \d+.*$/./;

        my $numScriptLines   =   1  +  $recScript_ =~ tr/\n//;
        _printError( "\nError when executing record script on id '$id'" );
        _printError(  ( $numScriptLines  <  20  )
                      ?  ":\n\n  $recScript_\n\n$message"
                      :  ". $message"                      );
        undef $SIG{__DIE__};
        exit -1;
    };
    #== END_SKIP


    while(   $line_  =  <$fastaInputStream_>   ){

        if(  $line_ =~ /^#/  ){
            if(  $noHeadSeenYet_  ){   $commentAtStartOfStream  .=  $line_;   }
            else                   {   $comment                 .=  $line_;   }

            next;  #  Read Next Line.
        }

        chop $line_;

        #  ----------  $line is not a comment...

        if(  $line_ =~ /^>/  ){   # Start of new record.

            _printInputError( "record has no body. Head line is:\n$line_" )
                if(  _atEndOfRecord( $fastaInputStream_ )  );
                
            $noHeadSeenYet_  =  0;
            $head  =  substr $line_, 1;  #  remove '>'.
            ($id)  =  ( $head =~ /^ \s* (\S+) \s* (.*) $/x );
            @head  =   $2 ?  split( $fs, $2 )  :  ();

            next;  #  Read Next Line.
        }


        #  ----------  $line is from the body of a record...

        ++$numSeqLines_;
        
        $maxSeqLineLenSeen_  =   length( $line_ )                #== IF  !$printSeqOn1Line_flag_;
            if(   length( $line_ )  >  $maxSeqLineLenSeen_   );  #== IF  !$printSeqOn1Line_flag_;

        #  Append sequence in $line_ to $seq.
        $seq  .=  $line_;

        #  If record completely read in, process it.
        if(  _atEndOfRecord( $fastaInputStream_ )  ){

            $seq  =~ s/[^$validSeqChars_arg_]//g;

            $numSeqLines_
                or  _printInputError( "no sequence found in entry $id with head line\n>$head" );

            #== IF	$needSeqArray_ && !$sortMode_flag_	@seq  =  split //, $seq;
            @seq  =  split //, $seq   if(  $needSeqArray_  );  #== SKIP

            #== EMBED-RECORD-SCRIPT-UNLESS-SORTING
            #== STORE-RECORD-IF-SORT-MODE

            #== BEG_SKIP
            if(  $sortMode_flag_  ){
                push @rec_,
                [   
                    $head,  [map {$_} @head],  $id,  $comment,
                    $seq,
                ];
            }

            else{  # not sort mode.

                no strict 'vars';

                my $printCurRecord_  =  $printEachRecord_flag_;

                my $retVal  =  eval $recScript_;
                $@  and  die( "Error in record script; $!\n" );

                $grepMode_flag_  and   $printCurRecord_ = $retVal;
                pr()  if( $printCurRecord_ );
            }
            #== END_SKIP


            #  -----  Reinitialize for next record  -----
            $comment = "";
            $head    = "";
            $seq     = "";
            @seq     = undef;  #== IF  $needSeqArray_
            $numSeqLines_  =  0;

        } # END:  if at end of record.

    }  # END:  while $line_ in fasta input stream.

} # END: _processInputStream( $fastaInputStream_ )



#  Return true iff $inputStream is at end of fasta record.
sub _atEndOfRecord{
    my $inputStream   =  shift;
    my $nextChar  =  getc $inputStream;
    
    if(  $nextChar  ){
        $inputStream->ungetc( ord $nextChar );
    }

    return(  !$nextChar  ||  $nextChar eq '>'  );
}
    


#  Print current fasta record to $os_
sub pr{

    # comments before first record are considered to belong to the stream, and are printed
    # exactly once, iff any part of the stream is printed.
    print $os_  $commentAtStartOfStream;
    $commentAtStartOfStream  = "";

    print $os_   ">$head\n$comment";

    _printSeq();
}



#  Print $seq with appropriate length lines.
sub _printSeq{

    my $on1Line  =  $printSeqOn1Line_flag_;

    if(  !$seqLineLength_arg_  ){              #== IF  $seqLineLength_arg_
        $on1Line  ||=  ($numSeqLines_ == 1);   #== IF  $seqLineLength_arg_
    }                                          #== IF  $seqLineLength_arg_

    if(  $on1Line  ){
        say $os_  $seq;
        return;
    }

    #  Else,
    _printSeqMultiline(   $seqLineLength_arg_
                          ||  $maxSeqLineLenSeen_  #== IF  !$printSeqOn1Line_flag_
        );

} #  END: _printSeq()



#  Print $seq, wrapping lines at $lineLen characters.
sub _printSeqMultiline{
    my $lineLen  =  shift;

    my $seqLen       =  length $seq;

    my $numSeqLines  =  $seqLen / $lineLen;    # number of completely full lines.

    ++$numSeqLines  if(  $seqLen % $lineLen  );  # final line is only partially full.

    for my $i (   0 ..  $numSeqLines-1    ){
        say $os_  substr( $seq, $i * $lineLen, $lineLen );
    }

} #  END: _printSeqMultiline()


#  Return true iff file $filename appears to be a fasta file.
#  Determined heuristically by looking for a line starting with '>'.
sub _looksLikeFastaFile{
    my $filename  =  shift;
    open( my $file, '<', $filename )
        or  _printUsageError(  "could not open fasta file '$filename', $!\n"  );
    my $retVal = 0;

    while(  <$file>  ){
        if(  /^>/  ){   $retVal = 1;  last;   }
    }

    close $file;
    return $retVal;
}


#  Heuristically determine if $s looks like perl-code.
#  Only used for command line parsing error diagnostics.
sub _looksLikePerlCode{
    my $s  =  shift;
    return ( $s =~ /[\$@]/ );
}


#  Sets global $os_
sub _standalone_parseArgvOptions{
    my $usage = "$0 [-o outputFile] [fastInputFile...]\n";

    $ARGV[0]  or  return;  #  If no args given, do nothing.

    if(  $ARGV[0] =~ /^-o$|^--output-file$/  ){
        $ARGV[1]  or  die "output file missing\n$usage\n";
        _standalone_openOutStream( $ARGV[1] );
        splice( @ARGV, 0, 2 );
    }
}

#  open $os_
sub _standalone_openOutStream{
    my $outputFilename  =  shift;

    if(  $outputFilename  ){
        open $os_, '>', $outputFilename
            or   _printUsageError(  "could not open output file '$outputFilename'\n"  );
    }
}


#== END_INCLUDE-COMMON
# =============================================================================

__END__

=pod


=head1  NAME

fastapl -- Fasta Perl Loop S<  aka  "fasta apple">


=head1  SYNOPSIS

B<fastapl>  [I<-opts>] I<script_file> [I<fasta_file>...]

B<fastapl>  [I<-opts>] B<-e> I<script> [I<fasta_file>...]

B<fastapl>  [I<-opts>] [B<-b> I<beginScript>] B<-e> I<script> [B<-f> endScript] [I<fasta_file>...]

B<fastapl>  [I<-opts>] B<-n> [B<-b> I<beginScript>] B<-e> I<script> [B<-f> endScript]

B<fastapl>  [I<-opts>] B<-n> <script_file>

B<fastapl>  B<--usage>|B<--help>|B<--man>


=head1  DESCRIPTION

B<fastapl> (Fasta Perl Loop) helps people write quick scripts to manipulate fasta
format files. Programmers familier with the
awk language or one-liner style Perl programming will recognize B<fastapl> to be the same
idea but with fasta records as the basic unit rather than lines.

=head2  User Scripts

B<fastapl> is basically a wrapper around user supplied code to be
executed on each record of a fasta file (or on each record pair
compared when sorting), also optionally before and after reading the
input stream.


=head1  ARGUMENTS

=over 8

=item I<script_file>

File containing Perl code to apply to each record (or to compare records when
L<sorting|"s_sort">). Normally a script must be given either with this I<script_file> or
directly with B<L<-e|"e_script_script">>, but not both.

(However the script can be omitted in special cases like this:

  % fastapl  -pl 100  foo.fa

in which B<L<-p|"p_print_each_record">> and either B<L<-1E<verbar>--print-seq-on-1-line|--print-seq-on-1-line>> or B<L<-lE<verbar>--line-length|"l_line_length_length">> are given; in which case the records are simply reformatted).


=for html <a name="begin_and_end"></a>

Can optionally contain BEGIN (executed once at the beginning) and END (executed once
just before termination) blocks. For example, this script outputs the total number of
residues in all sequences combined.

  BEGIN{
      $totSeqLen = 0;  # not really necessary, Perl vars default to 0.
  }

  $totSeqLen  +=  length( $seq );

  END{
     print "total = $totSeqLen\n";
  }


=item [I<fasta_file>]

File containing input sequences in fasta format. If this argument
is omitted, standard input is used. Alternatively, "-" denotes
standard input and can be mixed with input from files. For example,


  % fastapl script.fpl  foo.fa goo.fa hoo.fa

  % cat foo.fa goo.fa hoo.ha  |  fastapl script.fpl

  % cat goo.fa  |  fastapl script.fpl  foo.fa - hoo.fa

All do the same thing.


See L<"FASTA INPUT FORMAT"> for details about
the input format.

=back



=head1  OPTIONS

=over 8


=item B<-e|--script> I<script>

Inline script to execute on each record. May optionally contain L<BEGIN and/or
END blocks|"begin_and_end"> as well. Mnemonic: like C<perl -e>.


=item B<-b|--begin> I<script>

Script to execute once at beginning.  Mutually exclusive alternative
to including a L<BEGIN block|"begin_and_end"> in the main script. Can only be used with
inline scripts given with the B<-e> flag. Mnemonic: B<-b> for B<b>egin.


=item B<-f|--end> I<script>

Script to execute once at end.  Mutually exclusive alternative
to including an L<END block|"begin_and_end"> in the main script. Can only be used with
inline scripts given with the B<-e>|B<--main-script> flag. Mnemonic: B<-f> for B<f>inal.


=item B<-F|--field-separator> I<fieldSeparator>

Regular expression field separator used when computing
B<L<@head|"@head">>.  Visible in user scripts
as the variable B<L<$fs|"$fs">>. Defaults to the tab character.

For example, to compute a histogram of the first field, treating the part of the
L<head line|"FASTA INPUT FORMAT"> past the id as a white space separated list:

  % fastapl  -F '\s+'  -e '++$f{ $head[0] }'  -f 'print "$_:$f{$_}\n" for( keys %f )'

Mnemonic: like C<perl -F> or C<awk -F>.


=item B<-n|--generate-standalone>

Instead of processing an input stream, generate a specialized
standalone program with the user script embedded and output this to
stdout. The fasta input file is not needed when this option is
stipulated.

  % fastapl  -np  -e '$seq = lc $seq'  >  fastaDowncaser.pl

Creates a program which downcases sequences. And can be used like:

  % perl fastaDowncaser.pl foo.fa  >  fooDowncased.fa

This option is useful for debugging user scripts. Standalone scripts
also may run slightly faster.  Standalone
scripts do not suppress warnings such as "only used once". This
is intentional. Mnemonic: like C<make -n>.


=item B<-g|--grep>

Print record when user record script returns true. For example,
to print sequences starting with 'M' use:

  % fastapl -ge '$seq ~= /^M/'


=item B<-l|--line-length> I<length>

Sequence line length to use when printing records.
Mutually exclusive to B<L<--print-seq-on-1-line|"1_print_seq_on_1_line">>.
If neither of these is stipulated, an attempt is made to mimic the input record format (see B<L<pr()|"pr">>).


=item B<-M|--module> I<module>

Convenience option for preloading non-builtin modules.
Performs S<eval "use module";> before executing any scripts.
Alternative to using S<B<-b> "use module">. Mnemonic: like C<perl -m>.
Can be used multiple times in one command line. For example,


 % fastapl                                    \
     -M  'List::Util qw(sum)'                 \
     -M   fastaplAmino                        \
     -b  '%h = properties("Kyte Doolittle")'  \
     -e  '$hyd = sum( @h{@seq[1..19]} );      \
          print "av. hyd: ", $hyd/19, "\n"'


prints, for each sequence, the average hydrophobicity of the second through
19th residue.


=item B<-o|--output-file>

Output file. Defaults to stdout.


=item B<-p|--print-each-record>

Print each record after the record user script is executed. Mnemonic:
like C<perl -p>. For example, to reverse complement DNA sequences
use:

  % fastapl -pe '$seq = reverse $seq; $seq =~ tr/acgtACGT/tgcaTGCA/'


=item B<-1|--print-seq-on-1-line>

When printing records, always output sequences on one line.
Mutually exclusive to B<L<--line-length|"l_line_length_length">>.
If neither of these is stipulated, an attempt is made to mimic the input record format (see B<L<pr()|"pr">>).

=item B<-s|--sort>

Sort the records, using the user L<script|"e_script_script"> to compare record pairs.
The same L<record variables|"record variables"> are available as usual, but
with "1" or "2" appended. For example, to sort records by id use:

  % fastapl   --sort  -e '$id1 cmp $id2'

To sort by sequence length use:

  % fastapl  --sort  -e 'length $seq1 <=> length $seq2'

B<Warning:> this option uses a lot of memory. Roughly as much
as the input file size.


=item B<-c|--valid-sequence-chars>

Characters allowed to be included in sequences. Other characters
in record body are silently ignored. Defaults to '[-a-zA-Z]'.


=item B<-V|--version>

Print version and exit.

=back


=head1  VARIABLES/FUNCTIONS PROVIDED TO SCRIPTS

=head2  Record Variables

=over 8

=item B<$head>

The line starting with '>', but excluding the '>' character.

B<Note:> historically this line has been referred to as the "comment line" (despite
the fact that it is required for multifasta format). We define L<comment lines|"comment
lines"> to be truly optional lines starting with '#'.


=item B<@head>

The array obtained by considering the part of the head line after the id as a tab
separated field list (more precisely B<L<$fs|"$fs">> separated fields).


=item B<$id>

Sequence id (record name) as found in the head line. More precisely:

  ($id)  =  ( $head =~ /^\s*(\S+)/ );


=item B<$seq>

Sequence as a scalar.

=item B<@seq>

Sequence as an array, each residue is one element. Upon reading
each record, B<@seq> is set with: C< @seq  =  split //, $seq>.

B<Warning:> modifying @seq does not affect the output of B<L<pr()|"pr">>.


=item B<$comment>

Record L<comment lines|"comment lines">.


=back


=head2  Other Variables

=over 8

=item B<$fs>

Field separator used to compute B<L<@head|"@head">>. Can be
stipulated on command line with the B<L<-F|"f_field_separator_fieldseparator">> argument.
Defaults to the tab character "\t". Mnemonic: like FS varible in C<awk>, abbreviation of "B<F>ield B<S>eparator".

=back


=head2  Subroutines

=over 8

=item B<asHash(> [I<@a>] B<)>

Returns the hash containing any elements of B<@a> which look like "I<name>B<=>I<value>"
pairs. When omitted, B<@a> defaults to B<L<@head|"@head">>. For example, if L<$fs|"$fs">
stipulates space separated fields and B<L<$head|$head>> holds: "id temp=451 dummy 3s=36,24,36";
B<asHash()> should return: ("temp", "451", "3s", "36,24,36").


=item B<pr()>

Prints current record.
If neither B<L<--print-seq-on-1-line|"1_print_seq_on_1_line>> nor B<L<--line-length|"l_line_length_length">> are stipulated,
an attempt is made to mimic the input record format.  More precisely, if the current input
record's sequence is all on one line, the output sequence is placed entirely on one line.
Otherwise, the length of the first sequence line of the current input record is used.

Comment lines are printed after the head line, before any sequence lines.

Usually B<pr()> does not need to be called explicitly because it can be called
implicitly with the B<L<-p|"p_print_each_record">> and B<L<-g|"g_grep">> options.
Mnemonic: abbreviation of "B<P>rint B<R>ecord".


=back


=head1  FASTA INPUT FORMAT

The input format is a slight generalization of multifasta. Lines starting with ">"
denote the first line of a record. We call this line the "head". Other lines form the
body of each record. The "sequence" is the concatenation of these lines, ignoring
L<comment lines|"comment lines"> and non-valid sequence characters. A consequence
of this is that the sequences of "*" terminated records are read okay but the trailing
"*" is stripped when output. If "*" terminated records are needed try:

  % fastapl  -pe '$seq .= "*"'  input.fa  >  output.fa


=head2  Comment Lines

Formalizing a practice already used by some, we consider lines starting with "#"
to be comment lines. We further divide comments into three sub-categories:

  stream comments  --  "# lines" before the first head line of a stream.
  record comments  --  "# lines" inside a record (before a sequence line).
  other            --  "# lines" after the final sequence line of a record.
                +  non-"#-lines" that lack any valid sequence characters.

Here is an example illustrating our classification of lines starting with "#".

    #  Comment associated with whole stream
    > id1
    #  Comment associated with record X.
    MDLAFDPHFRPOENDGFSDOREAERFLKAWAE
    #  Another comment associated with record X.
    ITYKCEESFVKIPGEKDSVICLKGSQWSDIEE
    #  Stray comment, will be silently ignored
    > id2
    ...

Stream comments are associated with the stream as a whole, so B<fastapl> prints them at
the beginning of any non-empty output.  Record comments are associated with the record
which contains them, so they are printed along their record when/if it is printed. Other
comments are ignored (quietly skipped during input and never printed).


=head1  PREREQUISITES

This program requires the following modules:

  IO::File        for ungetc(), used to undo peek at '>' char of next record.
  Getopt::Long    for argv parsing.
  Pod::Usage      for --usage|--help|--man message processing.
  Text::Balanced  for extracting BEGIN and END blocks from user scripts.


=head1  COREQUISITES

  List::Util      for functions like shuffle(), useful in user scripts.
  fastaplAmino    for amino acid properties, etc.


=head1  OSNAMES

Currently only tested on linux.


=head1  SCRIPT CATEGORIES

Scientific/Bioinformatics


=head1  BUGS

No known bugs.


=head1  ISSUES

The errors in user scripts are hard to debug.  Currently the best
workaround is to generate a standalone program with the
B<L<-n|"n_generate-standalone">> option and debug that program
directly.

Not optimized for speed. L<Sorting|"s_sort"> is especially slow.

Does not try to preserve record formatting (for example, record
comment lines are always grouped together when output. A version which
does -- at the cost of being slower and using more memory -- is
available from the author.


=head1  LICENSE

You may use this program under the GNU General Public License (GPLv3).


=head1  ORGANIZATION

AIST, Computational Biology Research Center


=head1  AUTHOR

Paul Horton <horton-p AT aist.go.jp>


=head1  COPYRIGHT

Copyright (C) 2010, 2011.

=cut
